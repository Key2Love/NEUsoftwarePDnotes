# 2020

## C语言设计部分

### 选择7 p242

有下列程序段

int a=1,x=1;

while(a<10)

x++;

a++;

则while循环体执行的次数是**无限次**

### 解答

![image-20201010214515982](/Users/admin/Library/Application Support/typora-user-images/image-20201010214515982.png)

如果该题变为

int a=1,x=1;

while(a<10)

{x++;

a++;}

加上了花括号

那么循环体执行9次。

### 给出计算结果2 p243

**ffbcde**

```c
#include <stdio.h>
#include <string.h>
void fun(char *str)
{
	char temp;
	int n,i;
	n = strlen(str);
	temp = str[n-1];
	for(i = n-1;i>0;i--)
	{
		str[i] = str[i-1];
		str[0] = temp;
    // 以下两行是我自己加的，为了看中间结果是啥 
    
    // 这一行是为了看temp这个字符变化了没。
		printf("%c\n",temp);
    // 这一行是为了看str这次变成了啥
    printf("%s\n",str);
	}
}	
int main()
{
   char s[50];
   scanf("%s",s);
   fun(s);
   printf("最终输出---%s",s);
}
```

n = 6

i=5 fbcdee

i=4 fbcdde

i=3 fbccde

i=2 fbbcde

i=1 ffbcde

i=0 无法进入循环

![image-20201010220924420](/Users/admin/Library/Application Support/typora-user-images/image-20201010220924420.png)

## 数据结构部分

### 选择4 p245

在一个包含1000个元素的有序序列中查找某个元素，如果采用线性查找最多比较个1000元素，如果采用二分查找最多比较**10**个元素。

### 解答

计算公式：

![img](https://bkimg.cdn.bcebos.com/formula/2407731a0ccaa91127f948304d88ec58.svg)

当顺序表有n个关键字时：

查找失败时，至少比较a次关键字；查找成功时，最多比较关键字次数是b。

注意：a,b,n均为正整数。

在这里 9<log2(1000)<10。a=9,b=10。

完全是公式，百度百科找到的。

### 简答题2 p245

已知一组关键字序列为{10,24,32,17,31,30,46}，采用哈希函数H(key)=key MOD 13，表长m=20，采用二次探测再散列的方法解决冲突。

(1)对关键字序列构造哈希表

(2)请计算该哈希表在等概率情况下平均查找长度

### 解答

如何构建

(hash(x)+di)%表长

di = i^2, i=0,1,2,3,4....

在这题就是 (x%13+di)%20

2) 此时我们已经有了这张表。

假设找10,10%13=10.发现正好10这个k对应的是10，那么这个是1

如果没找到，就找(10%13+1^2)%20，找到了就是2，找不到那就继续。

计算公司 sum(总次数)/关键字个数

关键字个数这题就是7。总次数就是这7个数的查找次数总和

>  感觉答案有点问题，同时教材里有描述，我带给你看。

# 2019

## C语言设计部分

### 选择题10 p239

若有结构体定义如下，规定int的字节数为4，则sizeof(S)为**8**

struct S{int b; float f;}a[3];

![image-20201011183326021](/Users/admin/Library/Application Support/typora-user-images/image-20201011183326021.png)

https://blog.csdn.net/qq_37858386/article/details/75909852

![image-20201011184752045](/Users/admin/Library/Application Support/typora-user-images/image-20201011184752045.png)

首先第一个b，偏移量是0，是int的大小4的整数倍。

第二个f，偏移量是4，是float的大小4的整数倍。

最后，总大小=最后一个的偏移量+最后一个的大小=4+4=8

同时满足总大小是所有成员大小的整数倍，是他们的公约数。

### 二(2)结果输出 p239

```c
#include <stdio.h>
#include <string.h>
void Fun(char s[])
{
    // s是个字符数组 但实际上是指向字符数组首地址的指针 下面这句代码里是声明一个指针p的
    // 比如 char *p = s 就是说声明一个指针p指向字符数组s的首地址
    // 首地址就是第一个字符的地址
    // 然后 strlen(s) - 1 就是字符串s长度减1
    // 所以这句的意思是 指针p指向s的首地址+4-1 也就是指向字符D的地址
    // 也就是指向最后一位字符的地址
    char *p = s + strlen(s) - 1;

    // 下面的比较是把s的首地址和指针p指向的地址比较
    // 刚才p指向s最后一个字符的地址了 这里是当p指向的地址大于s首地址的时候一直循环
    while (s < p)
    {
        //这段
        printf("%p %c\n", s, s[0]);
        printf("%p %c\n", s + 1, s[1]);
        printf("%p %c\n", s + 2, s[2]);
        printf("%p %c\n", s + 3, s[3]);
        printf("s addr:%p p addr:%p\n", s, p);
        //下面两句没有任何意义。。声明一个字符等于s指向的那个字符 然后把这个字符赋值给s指向的字符
        char t = *s;
        *s = t;

        // *p-- 意思是先取值，再进行自减操作 也就是先取指针p然后把p指向的地址-1
        // *s++ 是先取值，再进行自增操作 也就是先取指针s的地址再把s指向的地址+1
        // 总结一下就是这句代码可以换成下面三句 意思是把s指向的字符赋值给p指向的内容，然后指针p往前走 指针s往后走
        //*p-- = *s++;
        *p = *s;
        p--;
        s++;
    }
    printf("%p %c\n", s, s[0]);
    printf("%p %c\n", s + 1, s[1]);
    printf("%p %c\n", s + 2, s[2]);
    printf("%p %c\n", s + 3, s[3]);
    printf("s addr:%p p addr:%p\n", s, p);
}

int main()
{
    char s[4] = "GOOD";
    //这里其实只是把s的首地址传了进去，里面对字符串的改动不会影响main函数里声明的这个s的地址！！！
    //Fun里面的s和这个s不是一个s,相当于复制了一个首地址指针作为参数传了进去
    Fun(s);
    printf("%s\n", s);
}
```

# 2018

## c语言设计部分

### 选择9 p235

![image-20201011213648872](/Users/admin/Library/Application Support/typora-user-images/image-20201011213648872.png)

首先局部变量默认是auto，但是绝对有static类型的局部变量

全局变量默认是extern。

c不谈，错的肯定

全局变量、静态变量的生命周期相同，都是直到程序结束才被释放

# 2017

## c语言

### 选择2 p230

![image-20201011215531881](/Users/admin/Library/Application Support/typora-user-images/image-20201011215531881.png)

![image-20201011215813671](/Users/admin/Library/Application Support/typora-user-images/image-20201011215813671.png)

A选项，此时我们只有定义，则这些值默认都是0。如果我们不给x,y赋值的话，x-y=0是无法作为除数的。但是如果都赋值了那就没有问题

B选项，先执行x！=y判断x是否不等于y，为真返回1否则返回0，将其返回值赋给a。

但是其实论式子本身，两个都对。A选项只是在一些极端情况会报错。

### 选择4 p230

![image-20201011220651081](/Users/admin/Library/Application Support/typora-user-images/image-20201011220651081.png)

0

这题它用了省略，原始的应该是

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20201011221138272.png" alt="image-20201011221138272" style="zoom:40%;" />

嵌套的if-else应当以一种自底向上的方式看。我们找到最后一个if，也就是最里面的if，让它和最接近它的else匹配。然后看倒数第二个，然后再匹配。但是注意一点，一个if所对应的else一定是在它的下面。

同时这种省略{}花括号的写法只能把一行的代码放到控制域内。

## 数据结构

### 选择1 p233

你是对的，A、D不能用栈得到。

![image-20201011222420410](/Users/admin/Library/Application Support/typora-user-images/image-20201011222420410.png)

### 二 1(3) p234

![image-20201012094234784](/Users/admin/Library/Application Support/typora-user-images/image-20201012094234784.png)

p可以根据有多少个关键字来指定。

你是对的

# 2016

## c语言设计部分

### 选择题 19 p227

![image-20201012100348752](/Users/admin/Library/Application Support/typora-user-images/image-20201012100348752.png)

## 数据结构

## 选择2 p227

你是对的，答案错了

### 简答题2 p228

给出一组树12，2，16，30，8，28，4，10，20，6，18，写出快排前两趟结果。

4,2,6,10,8,12,28,30,20,16,18
2,4,6,10,8,12,28,30,20,16,18

https://zhuanlan.zhihu.com/p/77659847

# 2015

## c语言设计部分

### 选择题10	p222

在调用函数时，实参是简单变量，它对应形参之间的数据传递方式是

A、地址传递

**B、单向值传递**

C、由实参传递给形参

D、由形参传回实参

我也觉得选B，毕竟题目强调简单变量

![image-20201012111411195](/Users/admin/Library/Application Support/typora-user-images/image-20201012111411195.png)

### 选择题9 p222

```c
#include <stdio.h>

main()
{
   int k=4,m=1,p;
   p=func(k,m);
   printf("%d",p);
   p=func(k,m);
   printf("%d\n",p);
}
func(int a,int b)
{
	static int m=0,i=2;
	i+=m+1;
	m=i+a+b;
	return m;
}
```

static int m=0,i=2;

两个都是静态类型。根据我的测试，确实都是static

## 数据结构

设顺序表的长度为n,则插入的平均比较次数为

出现在第一位，比较1次，出现在第n位比较n次，一共比较1+2+3+...+n=n(n+1)/2

平均比较次数为：一共比较次数（各种情况下）/各种情况（n种情况）=n(n+1)/2/n=(n+1)/2

https://www.nowcoder.com/questionTerminal/740f7991244545ac9c45dad571cd7849

![image-20201012212316260](/Users/admin/Library/Application Support/typora-user-images/image-20201012212316260.png)

